# linux 整理复习总结

## 简单概括

1. 常见命令
find 命令  管道符神奇作用 ls-al | grep "d"
2. linux目录结构 filesystem被挂载到目录下 -》此时目录下面就有空间了 -》扩容问题？？？-》深入看看目录结构问题
3. >> > 重定向符号的作用 追加末尾以及清空追加
4. 关于shell的底层原理 —》个人感觉是一个在用户和操作系统中间的转换着，一个现成的安全的轮子 比如ls mv都是一个个的可执行程序  输出ls 就是shell去进行调用
5. 所有者u 所属组g 其他用户o + umask掩码 777是默认权限 -》(默认权限)&(~umask) = 创建文件的权限 ->默认的给定权限需要确认 ->chomd ugo+rwx 文件名  chown 修改文件所有者 chgrp 修改所属组
6. 粘滞位 ？？
7. 文件互传工具 sz rz sftp


## 冯诺依曼体系结构
1. 各组件担任角色
2. cpu分时机制 + 操作系统调度机制lrulfu
3. 内核和用户态的切换-》中断 异常 系统调用
4. volatile 关键字
5. 函数的可重入和不可重入


## 进程是什么
1. pcb详细信息 以及 pcb组织方式
2. 进程状态 
3. 僵尸进程和守护进程 守护进程的实现
4. 虚拟地址空间 + 分段分页式内存管理 + 计算方式 + 程序地址空间再复习 -》MMU概念内存管理单元负责虚拟地址到物理地址的转换(地址转换，内存保护等 )
5. 缺页中断 + 页面调度算法 随机调度 + 先进先出FIFO + LFU(最近最久未使用) + LRU(最近最少未使用) +OPT(以后不会使用或很久不用)
6. 进程优先级调度的cpu优先级队列 queue+list方式
7. 从程序地址空间分析 写时拷贝 原理 fork原理 -》可以和string的写时拷贝进行对比 + 四级分页模型 + 实现原理(简单原理和函数实现) 

## 进程控制 
1. 进程等待 waitpid指定pid与方式  wait阻塞等待任意 -》不管什么时候退出都可以处理
2. status的意义与作用
  32位无符号整数 + 低16高八位保存返回值，低8位高一位coredump， 低七位信号
  coredump 发生异常的时候进行产生的文件， 可以指定生成与否
3. 进程退出 return + exit() + _exit() 区别是什么 + 库函数和系统调用接口区别 （刷新缓冲区等）
  缓冲区的意义: 缓冲区的意义为了提高执行效率 缓冲取其实是内存， 为了让cpu不等待外设所以将数据先放到缓冲区。
4. 程序替换 exec函数族 (被替换的程序 替换的程序 路径) 比如我们可以替换ls变成打印helloworld 等到程序执行到位置时候就会进行替换
5. 为什么输出./main就会执行呢 -》其实是shell进行子进程创建 程序替换

# 文件IO 
1. 标准库的基础操作 
2. 各种 r w a b + 等不同的区别 fopen
  r w 只读或者只写方式打开 不存在报错  r+ w+ 打开文件不存在创建
  a追加读写 a+不存在创建
  b 默认不指定以文本操作 指定以二进制进行操作
3. fread fwrite fseek 等等 都是文件IO的操作函数

4. 系统调用接口 open close write read lseek ->umask(0) O_RDONLY O_CREAT O_WRONLY O_APPEND 等等

5. struct file 结构体 描述文件详细信息 stdin out err 012  —》pcb有结构体数组-》存储的元素文件的详细信息-》通过数组下标进行访问。

6. dup2 重定向 以及重定向的原理

## 文件系统 软硬链接 动态库静态库
1. 磁盘分区 inode datenode 超级块 等
2. ext2 ext3等文件系统的区别todo
3. 数据的存储流程和查询流程
4. 软链接硬链接 ln  ln -s  两种文件的区别
5. 动态库和静态库的区别  静态库编译时载入 -》动态库连接时载入  
  fPIC 生成与位置无关代码， 动态库不允许使用强地址，因为地址不确定 -》后缀不同
  动态库-》先生成点o文件-》生成so库
  静态库-》先生成点o-》生成静态库a
  /usr/lib  /usr/lib64 库的加载路径
  环境变量 环境变量的组织方式 字符指针数组组织(main函数第三个参数就是这个数组的首地址)

## 进程间通信 IPC
ipcs ipcrm
1. 管道 命名和匿名
  本质是内核的缓冲区
  int pipe(int pipefd[2]) 一个是用于0读一个是用于1写 其实使两个文件描述符
  管道的读写特性 读阻塞 写异常 等等
  存在两次内核态到用户态的拷贝
2. 共享内存 
  最快的进程间通信方式 从底层进行探讨 直接在物理空间开辟空间双方pcb进行映射-》零拷贝
  操作流程-》创建-》建立映射-》对内存进行操作-》解除虚拟地址空间的映射关系-》释放共享内存资源
  shmget 创建 -》shmat建立映射 -》shmdt 解除映射 -》shmctl 删除共享内存
3. 消息队列
  内核中的一个优先级队列-》多个进程访问-》通过对队列的存储和取出进行通信
  优先级队列其实是堆 特殊的队列
  msgget -》msgsnd -》msgctl  也就是创建 添加 取出 释放

4. 信号量
  用于实现同步与互斥 -》本质是一个计数器和一个pcb的等待队列
  同步的实现 -》和零比较 加入等待队列
  互斥的实现 -》01判断能否访问

不同的特性 -》同步互斥等方式-》本质 —》使用方式

## 进程信号
1. 信号是一个软件中断 -》打断当前的操作，从而处理当前的事情
1-31非可靠信号 只注册一次 34-64可靠信号 注册多次 -》总共62个
2. 信号的生命周期 
  产生-》注册-》注销-》处理
3. 组织方式 简单说 位图标识有没有信号需要处理 链表中存储信号具体信息用于处理(可靠信号可以存在多个) —》一个信号对应一个handler回调函数

4. 信号是针对与整个进程进行处理的 ->信号的处理方式 (默认  自定义 忽略)

5. 先注销再处理的原因   一个进程中有多个线程， 但是信号针对于进程，因此只需要一个线程抢占即可， 所以需要先注销后处理。

6. 信号阻塞 底层是一个block位图 将信号添加或者移除即可

7. 应用 使用信号的自定义处理方式以及阻塞 可以产生我们想要的过程

## 多线程部分 
线程概念 线程控制 线程安全 线程基本应用 
### 进程概念
1. pcb tcb 一个进程使用一个虚拟地址空间 但是一个线程是一个pcb 共用一个虚拟地址空间 pcb不是是严格意义上的pcb
轻量级进程 

2. 线程之间独有和共享的数据

3. 多线程 和 多进程的独有和共享 -》成本 调度 健壮性 ，
对于IO cpu密集程序如何选择 (执行流 cpu核心数+1)
### 进程控制
线程的创建 等待 分离 
### 线程安全
1. 同步和互斥的概念 主要实现互斥
2. 互斥锁 底层 01计数器原子操作原理
3. 死锁产生的四个必要条件
4. 操作 -》创建 + 初始化 + 加锁(阻塞 非阻塞) + 解锁 + 销毁

5. 条件变量 pcb等待队列  -》主要实现同步 让线程有序进行
6. 定义 + 初始化 + 挂起线程休眠 + 唤醒 + 销毁 

》》 互斥锁 + 条件变量 实现同步互斥

7. 信号量和上面类似 实现的话得两个 

### 线程池 

生产者消费者模型 -》实现  -》解耦 忙闲不均 并发

## 各种锁机制
1. 读写锁 -》原子锁 自旋锁 -》乐观锁 悲观锁 -》
2. 有锁编程和无锁编程

## 单例模式
